import { render, screen, waitFor, fireEvent } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { describe, it, expect, beforeEach, vi } from 'vitest'
import React from 'react'
import { CharacterSheet } from '../../src/features/CharacterSheet'

// Mock the Firebase Auth context
vi.mock('@site/src/hooks/firebaseAuthContext', () => ({
  AuthProvider: ({ children }: { children: React.ReactNode }) => children,
  useAuth: () => ({
    userLoggedIn: true,
    isEmailUser: true,
    currentUser: {
      uid: 'test-user-id',
      email: 'test@example.com',
      displayName: 'Test User'
    },
    setCurrentUser: vi.fn(),
    isAdmin: false,
    setIsAdmin: vi.fn(),
  })
}))

// Mock the theme switcher component
vi.mock('@site/src/components/ThemeSwitcher', () => ({
  ThemeSwitcher: () => null
}))

// Mock Firebase SDK with enhanced tracking for comprehensive testing
vi.mock('firebase/firestore', () => ({
  doc: vi.fn(),
  getDoc: vi.fn().mockResolvedValue({ 
    exists: () => false,
    data: () => ({})
  }),
  setDoc: vi.fn().mockResolvedValue(undefined),
  updateDoc: vi.fn().mockResolvedValue(undefined),
  collection: vi.fn(),
  getDocs: vi.fn().mockResolvedValue({ docs: [] }),
  query: vi.fn(),
  where: vi.fn(),
  orderBy: vi.fn(),
  getFirestore: vi.fn(),
}))

vi.mock('firebase/auth', () => ({
  getAuth: vi.fn(() => ({
    currentUser: null,
    onAuthStateChanged: vi.fn(),
  })),
  onAuthStateChanged: vi.fn(),
}))

vi.mock('firebase/app', () => ({
  initializeApp: vi.fn(() => ({})),
  getApps: vi.fn(() => [{}]),
  getApp: vi.fn(() => ({})),
}))

// Mock the firebase config
vi.mock('@site/src/config/firebase', () => ({
  auth: {},
  db: {},
}))

describe('Character Sheet - Advanced Integration Testing & Cross-Tab Workflows', () => {
  beforeEach(() => {
    localStorage.clear()
    vi.clearAllMocks()
    
    Object.defineProperty(window, 'location', {
      writable: true,
      value: {
        search: '?id=integration-test-character',
        pathname: '/docs/tools/character-sheet',
        href: 'http://localhost:3000/docs/tools/character-sheet?id=integration-test-character',
        origin: 'http://localhost:3000',
        hash: '',
      }
    })

    // Set desktop viewport for comprehensive testing
    Object.defineProperty(window, 'innerWidth', {
      writable: true,
      configurable: true,
      value: 1920,
    })
  })

  it('should handle complete character creation workflow across all tabs', async () => {
    const user = userEvent.setup()
    
    render(<CharacterSheet />)
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    const tabs = screen.queryAllByRole('tab')
    console.log(`Found ${tabs.length} tabs for character creation workflow`)
    
    // Test workflow across multiple tabs
    if (tabs.length > 0) {
      // Start with first tab (usually Skills in desktop mode)
      await user.click(tabs[0])
      await waitFor(() => {
        expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
      }, { timeout: 2000 })
      
      // Test basic interaction in first tab
      const firstTabInputs = document.querySelectorAll('input')
      if (firstTabInputs.length > 0) {
        const input = firstTabInputs[0] as HTMLInputElement
        await user.clear(input)
        await user.type(input, 'Test Value 1')
        expect(input.value).toBe('Test Value 1')
      }
      
      // Navigate to next tab if available
      if (tabs.length > 1) {
        await user.click(tabs[1])
        await waitFor(() => {
          expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
        }, { timeout: 2000 })
        
        // Test interaction in second tab
        const secondTabInputs = document.querySelectorAll('input')
        if (secondTabInputs.length > 0) {
          const input = secondTabInputs[0] as HTMLInputElement
          await user.clear(input)
          await user.type(input, 'Test Value 2')
          expect(input.value).toBe('Test Value 2')
        }
      }
    }
    
    expect(tabs.length >= 0).toBe(true)
  })

  it('should maintain data persistence across full character sheet workflow', async () => {
    const user = userEvent.setup()
    
    render(<CharacterSheet />)
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    const tabs = screen.queryAllByRole('tab')
    
    // Create a comprehensive data modification workflow
    const testData = {
      skillValue: '4',
      itemName: 'Master Sword',
      spellName: 'Fireball',
      characterName: 'Hero of Time'
    }
    
    if (tabs.length >= 2) {
      // Test Skills tab data persistence
      await user.click(tabs[0])
      await waitFor(() => {
        expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
      }, { timeout: 2000 })
      
      const skillInputs = document.querySelectorAll('input[type="number"]')
      if (skillInputs.length > 0) {
        const skillInput = skillInputs[0] as HTMLInputElement
        await user.clear(skillInput)
        await user.type(skillInput, testData.skillValue)
        expect(skillInput.value).toBe(testData.skillValue)
      }
      
      // Test Items tab data persistence
      if (tabs.length > 1) {
        await user.click(tabs[1])
        await waitFor(() => {
          expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
        }, { timeout: 2000 })
        
        const itemInputs = document.querySelectorAll('input[type="text"]')
        if (itemInputs.length > 0) {
          const itemInput = itemInputs[0] as HTMLInputElement
          await user.clear(itemInput)
          await user.type(itemInput, testData.itemName)
          expect(itemInput.value).toBe(testData.itemName)
        }
        
        // Navigate back to Skills and verify data persistence
        await user.click(tabs[0])
        await waitFor(() => {
          expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
        }, { timeout: 2000 })
        
        const persistedSkillInputs = document.querySelectorAll('input[type="number"]')
        if (persistedSkillInputs.length > 0) {
          const persistedInput = persistedSkillInputs[0] as HTMLInputElement
          expect(persistedInput.value).toBe(testData.skillValue)
        }
      }
    }
    
    expect(tabs.length >= 0).toBe(true)
  })

  it('should handle auto-save triggers and data synchronization', async () => {
    const user = userEvent.setup()
    
    render(<CharacterSheet />)
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    const allInputs = document.querySelectorAll('input')
    
    if (allInputs.length > 0) {
      // Test multiple auto-save triggers
      for (let i = 0; i < Math.min(3, allInputs.length); i++) {
        const input = allInputs[i] as HTMLInputElement
        const testValue = `AutoSave${i}`
        
        await user.clear(input)
        await user.type(input, testValue)
        
        // Trigger blur to potentially activate auto-save
        fireEvent.blur(input)
        
        expect(input.value).toBe(testValue)
        
        // Small delay between auto-save triggers
        await new Promise(resolve => setTimeout(resolve, 200))
      }
      
      // Wait for potential batched auto-save operations
      await waitFor(() => {
        expect(true).toBe(true) // Just wait for settling
      }, { timeout: 2000 })
    }
    
    expect(allInputs.length >= 0).toBe(true)
  })

  it('should handle complex form validation and error states', async () => {
    const user = userEvent.setup()
    
    render(<CharacterSheet />)
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    // Test invalid input handling
    const numberInputs = document.querySelectorAll('input[type="number"]')
    
    if (numberInputs.length > 0) {
      const numberInput = numberInputs[0] as HTMLInputElement
      
      // Test negative value (might be invalid for some fields)
      await user.clear(numberInput)
      await user.type(numberInput, '-5')
      
      // Test extremely large value
      await user.clear(numberInput)
      await user.type(numberInput, '999999')
      
      // Test valid value to ensure it works
      await user.clear(numberInput)
      await user.type(numberInput, '10')
      
      expect(numberInput.value).toBe('10')
    }
    
    // Test text input validation
    const textInputs = document.querySelectorAll('input[type="text"]')
    
    if (textInputs.length > 0) {
      const textInput = textInputs[0] as HTMLInputElement
      
      // Test very long text (might trigger validation)
      const longText = 'A'.repeat(1000)
      await user.clear(textInput)
      await user.type(textInput, longText.substring(0, 50)) // Type only part to avoid timeout
      
      // Test special characters
      await user.clear(textInput)
      await user.type(textInput, 'Test@#$%')
      
      expect(textInput.value).toBe('Test@#$%')
    }
    
    expect(numberInputs.length >= 0 || textInputs.length >= 0).toBe(true)
  })

  it('should handle responsive layout changes during character editing', async () => {
    const user = userEvent.setup()
    
    render(<CharacterSheet />)
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    // Start in desktop mode, make some changes
    const desktopInputs = document.querySelectorAll('input')
    if (desktopInputs.length > 0) {
      const input = desktopInputs[0] as HTMLInputElement
      await user.clear(input)
      await user.type(input, 'Desktop Value')
      expect(input.value).toBe('Desktop Value')
    }
    
    // Switch to mobile viewport
    Object.defineProperty(window, 'innerWidth', {
      writable: true,
      configurable: true,
      value: 375,
    })
    window.dispatchEvent(new Event('resize'))
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    // Test interaction in mobile mode
    const mobileInputs = document.querySelectorAll('input')
    if (mobileInputs.length > 0) {
      const mobileInput = mobileInputs[0] as HTMLInputElement
      // Value should persist across layout changes
      expect(mobileInput.value).toBe('Desktop Value')
      
      // Test additional mobile interaction
      await user.clear(mobileInput)
      await user.type(mobileInput, 'Mobile Value')
      expect(mobileInput.value).toBe('Mobile Value')
    }
    
    // Switch back to desktop
    Object.defineProperty(window, 'innerWidth', {
      writable: true,
      configurable: true,
      value: 1920,
    })
    window.dispatchEvent(new Event('resize'))
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    // Verify data persistence after layout change
    const finalInputs = document.querySelectorAll('input')
    if (finalInputs.length > 0) {
      const finalInput = finalInputs[0] as HTMLInputElement
      expect(finalInput.value).toBe('Mobile Value')
    }
    
    expect(desktopInputs.length >= 0).toBe(true)
  })

  it('should handle bulk operations and batch updates', async () => {
    const user = userEvent.setup()
    
    render(<CharacterSheet />)
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    const allInputs = document.querySelectorAll('input')
    const batchSize = Math.min(5, allInputs.length)
    
    if (batchSize > 0) {
      // Perform batch updates without triggering blur events
      const batchValues: string[] = []
      
      for (let i = 0; i < batchSize; i++) {
        const input = allInputs[i] as HTMLInputElement
        const value = `Batch${i}`
        batchValues.push(value)
        
        await user.clear(input)
        await user.type(input, value)
        
        expect(input.value).toBe(value)
      }
      
      // Now trigger all blur events together (simulating bulk save)
      for (let i = 0; i < batchSize; i++) {
        fireEvent.blur(allInputs[i])
      }
      
      // Verify all values are maintained
      for (let i = 0; i < batchSize; i++) {
        const input = allInputs[i] as HTMLInputElement
        expect(input.value).toBe(batchValues[i])
      }
    }
    
    expect(allInputs.length >= 0).toBe(true)
  })

  it('should handle edge cases and error recovery', async () => {
    const user = userEvent.setup()
    
    render(<CharacterSheet />)
    
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    const tabs = screen.queryAllByRole('tab')
    
    // Test rapid tab switching
    if (tabs.length > 1) {
      for (let i = 0; i < Math.min(3, tabs.length); i++) {
        await user.click(tabs[i])
        // Brief wait to allow state updates
        await new Promise(resolve => setTimeout(resolve, 100))
      }
      
      // Should still be functional after rapid switching
      await waitFor(() => {
        expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
      }, { timeout: 2000 })
    }
    
    // Test rapid input changes
    const inputs = document.querySelectorAll('input')
    if (inputs.length > 0) {
      const testInput = inputs[0] as HTMLInputElement
      
      // Rapid value changes
      for (let i = 0; i < 5; i++) {
        await user.clear(testInput)
        await user.type(testInput, `Rapid${i}`)
        // Very brief pause
        await new Promise(resolve => setTimeout(resolve, 50))
      }
      
      // Final value should be set correctly
      expect(testInput.value).toBe('Rapid4')
    }
    
    // Test component recovery after errors
    try {
      // Simulate potential error condition by rapidly interacting with many elements
      const allInteractiveElements = document.querySelectorAll('input, button, select')
      for (let i = 0; i < Math.min(3, allInteractiveElements.length); i++) {
        const element = allInteractiveElements[i]
        if (element.tagName === 'INPUT') {
          await user.click(element)
        } else if (element.tagName === 'BUTTON') {
          await user.click(element)
        }
        await new Promise(resolve => setTimeout(resolve, 50))
      }
    } catch (error) {
      // Component should handle errors gracefully
      console.log('Handled interaction error:', error)
    }
    
    // Verify component is still functional
    await waitFor(() => {
      expect(screen.queryAllByRole("tab").length).toBeGreaterThan(0)
    }, { timeout: 2000 })
    
    expect(tabs.length >= 0).toBe(true)
  })
})